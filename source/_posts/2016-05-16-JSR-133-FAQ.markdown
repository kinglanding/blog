---
title: JSR-133 FAQ
date: 2016-05-16 16:18:24
tags: 
- java
- jvm 
- java内存模型
---

# 内存模型究竟是个啥玩意儿？

在多处理器的架构中，处理器一般拥有一到几层缓存，缓存是个好东西，它既可以用来提供获取数据的速度（缓存嘛~离处理器更近！），又可以减少
竞争共享内存总线的次数（因为很多内存数据的操作可以在缓存中完事儿~）。缓存可以惊人地提高性能，但同时也引入的新的挑战。如：
1. 如果两个处理器同时访问同一块内存区域，应该如何处理？
2. 在什么条件下，保证他们看到同样的值？

内存模型定义了在处理器层面上的重要条件：1. 其他处理器的写操作对当前处理可见；2. 当前处理的写操作对其他处理器可见。一些处理器（exhibit）
定义了**强内存模型**: 任何时间，任意处理器访问统一内存区域，读取的值都是一样的。还有一些处理器exhibit）实现了*若内存模型*：这种内存模型定义
了一种特殊指定，叫做**内存屏障(memory barriers)**, 这种指令会将本处理器缓存中数据清除或者置为无效，以此保证其他处理器的写操作对其可见；或者
本身的写操作对其他处理器可见。内存屏障一般随加锁，释放锁的操作一起执行。对高级语言来说，他们是不见的。

<!-- more -->

编写强内存模型的程序有时会更简单一些，因为减少了内存屏障这类指令的使用。但是，即使对于一些最强的内存模型，内存屏障也是必要的：他们所处的位置也是违反
直觉的。最新的处理器设计趋势是故事使用若内存模型，在多核处理和更大的内存量上，缓存一致性的松弛会带来更高的扩展性。

写操作对另外的线程何时可见取决于编译器对代码的重排序：例如，如果编译器或许会决定将一个写操作滞后会提高程序性能，只要代码移动不会改变程序的语义，当然可以
这么做。如果编译器延迟一个操作，另外一个线程只有在操作执行滞后才会看到：这反映了缓存的效果。

另外，写内存的操作也可以提前：这样场景下，其它线程很可能会在写操作实际**发生前**就看到它(例如volatile的内存语义)。这种灵活性都是提前设计好的。将这种灵活的操作
给与编译器，运行时，和硬件，形成代码的最有执行顺序，在内存模型的约束下，我们可以达到更高的性能。

参考以下简单的代码

```java
Class Reordering {
  int x = 0, y = 0;
  public void writer() {
    x = 1;
    y = 2;
  }

  public void reader() {
    int r1 = y;
    int r2 = x;
  }
}
```

假设现在有两个线程并行执行,并且读取y的值是2.因为y的写操作在x之后，你可能会认为x的值一定是1。但是，由于写操作有可能会重排序。如果这样，有可能代码的重排序
结果是这样的。先写y的值，然后在读取y和x，最后在写x。这种场景下r1的值就是2，r2的值就是0.

java内存模型了描述了并发场景下的合法行为，线程是如何和内存交互的。它描述了从内存、寄存器中存取变量的底层细节。这种模型可以使用各种硬件和各种各样的编译器优化正确的实现。

java包含一些语言关键字，比如**volatile**,**final**,和**synchronized**,这些关键词帮助程序员编写并发程序。JMM定义了volatile和synchronized的行为，最重要的是
，保证了正确的同步程序可以无误的跑在所有的处理器架构上。

# 其他语言，比如C++，有内存模型吗？
大多数程序编程语言，比如C和C++，并没有直接对多线程编程提供支持。所以这类语言的重排序的保证严重依赖于编译器和架构的保证，例如线程库，所使用的编译器，和目标运行平台。

# JSR 133描述了什么

从1997以来，原有的JMM发现了几个缺陷，这些瑕疵会导致令人困惑的行为（常量字段的值被观测到变化了），破坏编译器执行通用优化点能力。

Java Memory Model是一个雄心勃勃的进击：首次提出了编程规范，用可提供一致性语义的内存模型解决跨平台并发问题。不幸的是，定义一个一致性并且符合直觉的内存模型
被证明比预想的难。JSR 133模型定义了一个新的内存模型，修复了早期内存模型的缺陷。为了达到这一目的，**final**和**volatile**的语义需要做下改变。

JSR 133的目标:

1. 保存现有的安全保证，例如类型安全。加强其它方面。比如，变量值不能凭空产生：每个线程读到的变量值必须是某个线程合理赋值的。
2. 正确的同步程序语义必须尽简洁明了直观。
3. 不正确的同步程序语义应该制定清楚，最小化潜在的安全危害
4. 程序员可以自信地解释出多线程程序时如何和内存交互的
5. 尽可能在广大流行架构上设计跨平台、正确、高性能的JVM实现
6. **安全初始化**保证。如果一个对象被正确的构建（意味着对象构建期间，引用不会提前溢出或者对外发布），所有引用这个对象的线程都可以看到对象的final字段的值（在构建函数中
设置的值），并且不需要同步。
7. 对现有代码影响最小化。

# 重排序意味什么
有许多诸如访问变量的场景（对象的字段，类静态字段、数组元素），会按照看起来和代码写的顺序不一样的操作顺序执行。编译器会以最优化的名义自由重排序指令。
处理器可能会乱序执行指令。数据在集群器、缓存及内存中的移动顺序有可能和程序中指定的不一样。

比如，一个线程给a赋值，再给b赋值，并且a和b的操作无依赖，那么，编译器可以自由重排序这些操作。缓存可以把b写到内存中。编译器，JIT，缓存中都会做出重排序的操作。

编译器，运行时和影响可以协力创建看起来像串行执行的假象，对于一个单线程来说，重排序对他来说没有任何影响。但是重排序有可能导致多线程的执行结果异常。一个
线程观察到其他线程的影响；或者在正常的语义中，一些线程本不应该提前访问某个变量的值。

大多数时间，线程不需要关系其他线程做什么操作。但是有些时候，例如共享内存的场景，那么就需要进行同步操作了。

# 旧的内存模型存在的问题

之前旧的内存模型存在几个严重的问题。例如，不支持重排序。